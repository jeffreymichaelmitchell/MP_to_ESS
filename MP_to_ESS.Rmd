---
title: "MP_to_ESS"
output:
  output: github_document
date: "2025-04-22"
---

```{r setup, include=FALSE}
library(formatR)
knitr::opts_chunk$set(echo = TRUE)
```

## Manifesto Project to European Social Survey

This repository is to help students merge the longitudinal
Manifesto Project data to the European Social Survey. It selects the nationalist parties, and weights the indicators for national way of life, multiculturalism, and environmentalism by the party size. It also interpollates the data to make a country-year dataset, then merges the data to the European Social Survey. 

This code is easily adaptable to other indicators in the MP dataset, but it only matches the country year values to the ESS rounds. There are much more rigerous ways to match the MP and ESS data, see for example: 
https://github.com/sophieehill/ess-cumulative
and
https://github.com/denis-cohen/ess-election-dates


```{r,  warning=FALSE}
library(manifestoR)
library(tidyverse)
```

This code starts to download the data directly into R

```{r key }
mp_setapikey("manifesto_apikey.txt")

```
Download the data from the manifesto project into R what it returns is a dataframe where each row is a country-year-party observation so there are rows in every group for all parties in that election year, then the indicator
 
```{r download}
mpds<-mp_maindataset(version = "current", south_america =FALSE, download_format = NULL, apikey=NULL, cache = TRUE)
```

This code just fixes the date so that it is a ‘year’ measurement make the date only 4 digits

```{r fix year}
mpds<-mpds %>% 
  mutate(date= (date*.01)) %>% 
  mutate(date=round(date))
```

This selects the MP variables and filters the dataset to all elections in 1990 or after

Each row is a party in an election in a year in a country. 

Here I filter the data so that it only includes parties in countries with the Nationalist family (parfam 70), that are in the EU and after 1990. 

```{r select vars}
mpds<-mpds %>% 
  select(country, countryname, date, party, per601, per501, per608, absseat, totseats, eumember, parfam) %>% 
  filter(date> 1990 & parfam== 70 & eumember>1)
```

There is a small issue, Portugal only has one observation of a Nationalist party. All the other countries have at least 2

```{r}
table(mpds$countryname)
```
Lets filter Portugal out 

```{r}
mpds<- mpds %>% filter(countryname != 'Portugal')
```

This code makes a variable for the share of seats in parlement for each party in each election

```{r}
mpds$seat_share<-(mpds$absseat/mpds$totseats)*100
``` 

This code makes a variable for each parties' score on per601 weighted by their share of parliment

```{r}
mpds$per601_size<-mpds$per601*mpds$seat_share
mpds$per608_size<-mpds$per608*mpds$seat_share
mpds$per501_size<-mpds$per501*mpds$seat_share

``` 

The problem with this data is that the election years don't match with the ESS rounds. This means we need to get values for the years when the ESS was fielded. To do this I expand the dataframe so it includes a full sequence of years from 1990-2023

Notice I make it into a new data frame called ‘mpdf1’.  

```{r}
mpds1<- mpds %>% complete(countryname, date= full_seq(date, period= 1), fill= list(per601_size= NA))
``` 

Then I interpolate the missing values for each year. Basically this is where the year would fall on a line if you connected the two observed values it falls between.

For this, you will need to install and load the imputeTS package

```{r, warning=FALSE} 
library(imputeTS)

mpds1<-mpds1 %>% 
  group_by(countryname) %>% 
  mutate(per601_size= imputeTS::na_interpolation(per601_size)) %>% 
  mutate(per608_size= imputeTS::na_interpolation(per608_size)) %>% 
  mutate(per501_size= imputeTS::na_interpolation(per501_size))
``` 


 
Check how many country-year observations you have. This code will show what countries have more than 1 country year observation, but notice it does NOT save over the dataframe. It shows that there are several country-year observations with more than one nationalist party.  

```{r}
mpds1 %>% group_by(countryname, date) %>% 
   filter(n()>1)
```

It may be advisable to average the nationalist parties. You would do this by using something like the following code. It makes a new variables, like the one called ‘per601_size_mean’

This code also selects only the country, date, and indicator columns. Then the distinct command removes the duplicate rows.

The result are country-year values of the weighted average of those values for the nationalist parties in the manifesto project data.  

```{r}
mpds1<-mpds1%>% group_by(countryname, date) %>% mutate(per601_size_mean= mean(per601_size)) %>%
  mutate(per608_size_mean= mean(per608_size)) %>% 
  mutate(per501_size_mean= mean(per501_size)) %>% 
  select(countryname, date, per601_size_mean, per608_size_mean, per501_size_mean) %>% 
  distinct()
``` 

Now we can check again if there are any country years with more than 1 observation:

```{r}
mpds1 %>% group_by(countryname, date) %>% 
   filter(n()>1)
```

Now that you have a tidy data set for the macro variable you will do the demeaning procedure. 
  
For this bit of code you will need to install and load the datawizard package

This line of code makes a new dataframe with meaned (between) and demeaned (within) values. 

```{r, warning=FALSE}
library(datawizard)

mpds_demeaned<- demean(mpds1, select = c("per601_size_mean", "per608_size_mean", "per501_size_mean"), by = "countryname")
```

Then load the ESS data and call it 'ess'

```{r, warning=FALSE}

library(readr)
ess <- read_csv("ESS 1_11.csv")

```
Load the ess data and call it 'ess'

This next chunk of code makes a variable in the ess data frame with the full country names then makes a new year variable corresponding to the ess round. Then it will give you a table with the number of country-year observations.
 
```{r}
ess$country_full<- recode(ess$cntry, 
                  "AT"="Austria",
                  "BE"="Belgium",
                  "BG"="Bulgaria",
                  "CH"="Switzerland",
                  "CY"="Cyprus",
                  "CZ"="Czech Republic",
                  "DE"="Germany",
                  "DK"="Denmark",
                  "EE"="Estonia",
                  "ES"="Spain",
                  "FI"="Finland",
                  "FR"="France",
                  "GB"="United Kingdom",
                  "GR"="Greece",
                  "HR"="Croatia",
                  "HU"="Hungary",
                  "IE"="Ireland",
                  "IL"="Israel",
                  "IS"="Iceland",
                  "IT"="Italy",
                  "PL"="Poland",
                  "PT"="Portugal",
                  "LT"="Lithuania",
                  "LU"="Luxembourg",
                  "NL"="Netherlands",
                  "NO"="Norway",
                  "RU"="Russia",
                  "SE"="Sweden",
                  "SI"="Slovenia",
                  "SK"="Slovakia",
                  "TR"="Turkey",
                  "UA"="Ukraine",
                  "LV"="Latvia",
                  "RS"= "Serbia",
                  "ME"= "Montenegro",
                  'XK'= 'Kosovo',
                  'RO'= 'Romania',
                  'MK'= 'North Macedonia',
                  'AL'= 'Albania'

)


#This makes a year variable that corresponds to the ess round
ess$year<-recode(ess$essround,
                "1"="2002",
                "2"="2004",
                "3"="2006",
                "4"="2008",
                "5"="2010",
                "6"="2012",
                "7"="2014",
                "8"="2016",
                "9"="2018",
                "10"="2020",
                "11"="2023")

table(ess$country_full, ess$year)

```


Then merge the macrodata to the ess file

```{r}
ess$year<- as.numeric(ess$year)
ess_merged<- left_join(ess, mpds_demeaned, by= c('country_full'= 'countryname', 'year'='date'))

```

Then here you will need to match the nationalist party family list with the individual respondents. 
 
Future steps for modeling. We have now set up a macro level dataset that is able to model the cross sectional country differences (between) in political rhetoric on three indicators as well as how changes in those indicators (within) relate to individual level measures in the ESS.

For modeling this you’ll need to install and/or load the lme4 and lmerTest packages

Then the formula would look something like this 
m <- lmer(dependent_variable ~ x_between + x_within + (1 + x_within | country), data = ess_merged)
 
Then I like to report results using the sjPlot package. There is a ton of useful stuff in there. For example if you want a nice table of the results you can use:

tab_model(m)

There are also several plot functions in sjPlot. Here is a link to the package website:
https://strengejacke.github.io/sjPlot/index.html
